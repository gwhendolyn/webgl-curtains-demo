<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webgl curtains</title>
    <link rel="stylesheet" href="./stylesheets/global.css"/>
    <link rel="icon" href="./favicon.ico"/>
    <!--google fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
</head>

<body>
    <!------- vertex shaders ------->
    <script id="simple-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 uTextureMatrix0;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        void main() {
            vec3 vertexPosition = aVertexPosition;
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (uTextureMatrix0 * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="text-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 planeTextureMatrix;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        uniform float u_time;
        void main() {
            vec3 vertexPosition = aVertexPosition;
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="link-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 planeTextureMatrix;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        uniform float u_time;
        uniform int u_mouseover;
        void main() {
            vec3 vertexPosition = aVertexPosition;
            
            if (u_mouseover == 1){
                vertexPosition.z = sin(vertexPosition.x + u_time*2.0)*0.05;
            }

            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="ascii-vs" type="x-shader/x-vertex">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        uniform mat4 charSpriteSheetMatrix;

        void main(){
            gl_Position = vec4(aVertexPosition, 1.0);

            vTextureCoord = aTextureCoord;
            vVertexPosition = aVertexPosition;
        }
    </script>

    <script id="tile-vs" type="x-shader/x-vertex">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        uniform mat4 uColorMatrix;
        uniform mat4 uNormalMatrix;
        uniform mat4 uRoughnessMatrix;

        void main(){
            vec3 vertexPosition = aVertexPosition;
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition,1.0);

            vTextureCoord = (uColorMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="water-vs" type="x-shader/x-vertex">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uTilesMatrix;
        uniform float uTime;

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        varying vec3 vSurfaceNormal;
        varying float vCaustic;

        float random (in vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        
        #define OCTAVES 24.0
        void main(){
            vec3 vertexPosition = aVertexPosition;
            vec2 samplePos = vertexPosition.xy;
            vec2 directionVector = vec2(0.0);
            float amplitude = 0.0003;
            float wavelength = 0.15;
            float speed = 0.03;
            float partialDer = 0.0;
            vec3 binormal = vec3(1.0,0.0,0.0);
            vec3 tangent = vec3(0.0,1.0,0.0);
            float doubleDer = 0.0;
            float der = 0.0;

            for(float i = 1.0; i < OCTAVES+1.0; i++){
                //generate random direction vector
                directionVector.x = (random(vec2(i*1.3,i+1.2))-0.5)*2.0;
                directionVector.y = (random(vec2(i+1.11,i*1.5))-0.5)*2.0;
                directionVector = normalize(directionVector);
                
                //calculate wave height contribution and add to vertex z coord
                float val = amplitude * sin(dot(directionVector, samplePos) * (2.0/wavelength) + uTime * speed);
                vertexPosition.z += val;
                
                //calculate partial derivative and add to total derivative/ binormal and tangent z components
                partialDer = -amplitude * cos(dot(directionVector, samplePos) * (2.0/wavelength) + uTime * speed);
                der += partialDer;
                binormal.z += directionVector.x * partialDer;
                tangent.z += directionVector.y * partialDer;
                
                //add the double derivative to our rolling total
                doubleDer -= val;
                
                //adjust params
                amplitude *= 0.96;
                wavelength /= 1.06;
                samplePos.x += partialDer * directionVector.x;
                samplePos.y += partialDer * directionVector.y;
                speed *= 1.02;
            }

            vSurfaceNormal = cross(binormal, tangent);
            
            vCaustic = (smoothstep(0.0, 0.001, abs(der))) * -(doubleDer / abs(doubleDer));
            
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); 
            vTextureCoord = (uTilesMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>
    <!------------------------------>

    <!------ fragment shaders ------>
    <script id="simple-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D uSampler0;
        void main() {
            gl_FragColor = texture2D(uSampler0, vTextureCoord);
        }
    </script>

    <script id="light-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D uSampler0;
        
        void main() {
            vec4 sample = texture2D(uSampler0, vTextureCoord);
            sample.rgb = (1.0 - sample.rgb) * vec3(0.9021568627450,
                                                   0.9411764705882,
                                                   0.9725490196078);
            gl_FragColor = sample;
        }
    </script>

    <script id="black-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D uSampler0;
        void main() {
            vec3 color = vec3(0.0);
            gl_FragColor = vec4(color,1.0);
        }
    </script>

    <script id="text-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D planeTexture;
        void main() {
            gl_FragColor = texture2D(planeTexture, vTextureCoord);
        }
    </script>

    <script id="tileLink-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D planeTexture;
        uniform float u_mouseover;
        void main() {
            vec4 sample = texture2D(planeTexture, vTextureCoord);
            sample.rgb -= (0.9 * u_mouseover);
            gl_FragColor = sample;
        }
    </script>

    <script id="rainbowText-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D planeTexture;
        uniform float u_time;
        void main() {
            vec4 sample = texture2D(planeTexture, vTextureCoord);
            float phase = (u_time/4.0)+vTextureCoord.x*3.0;
            sample.rgb = sample.rgb * ((sin(phase)*0.5)+0.7) * vec3(0.7,1.0,1.0);
            gl_FragColor = sample;
        }
    </script>

    <script id="marble-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_time;
        uniform sampler2D uSampler0;

        varying vec2 vTextureCoord;
        float random (in vec2 _st) {
            return fract(sin(dot(_st.xy,
                                vec2(12.9898,78.233)))*
                43758.5453123);
        }

        // Based on Morgan McGuire @morgan3d
        // https://www.shadertoy.com/view/4dS3Wd
        float noise (in vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            // Four corners in 2D of a tile
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);

            return mix(a, b, u.x) +
                    (c - a)* u.y * (1.0 - u.x) +
                    (d - b) * u.x * u.y;
        }

        #define NUM_OCTAVES 6

        float fbm ( in vec2 _st) {
            float v = 0.0;
            float a = 1.5;
            vec2 shift = vec2(100.0);
            mat2 rot = mat2(cos(0.5), sin(0.5),
                            -sin(0.5), cos(0.50));
            for (int i = 0; i < NUM_OCTAVES; ++i) {
                v += a * noise(_st);
                _st = rot * _st * 2.0 + shift;
                a *= 0.5;
            }
            return v;
        }

        #define TIME_SCALE 0.065
        void main() {
            vec2 st = gl_FragCoord.xy/u_resolution.xy;
            st.x *= u_resolution.x/u_resolution.y;
            
            vec2 ms = u_mouse.xy/u_resolution.xy;
            ms.x *= u_resolution.x/u_resolution.y;
            float mouseProx = sqrt(pow(st.x-ms.x,2.0)+pow(st.y-ms.y,2.0));

            vec2 q = vec2(0.0);
            q.x = fbm(6.*st+u_time*(TIME_SCALE+0.015));
            q.y = fbm(6.*st+u_time*(TIME_SCALE+0.015));

            vec2 r = vec2(0.0);
            r.x = fbm((abs(mouseProx)*1.)*st + q+u_time*(TIME_SCALE+0.01));
            r.y = fbm((abs(mouseProx)*1.)*st + q+u_time*(TIME_SCALE+0.01));

            vec2 s = vec2(0.0);
            s.x = fbm(5.0*st + r+u_time*(TIME_SCALE+0.005));
            s.y = fbm(5.0*st + r+u_time*(TIME_SCALE+0.005));

            float t = fbm(st+s);

            vec3 color = vec3(t);
            
            color = mix(vec3(1.0, 1.0, 1.0),
                        vec3(0.4392156862745098, 0.8392156862745098, 1.0),
                        clamp(t-0.5,0.0,1.0));
            
            color = mix(color,
                        vec3(1.0, 0.4392156862745098, 0.6509803921568627),
                        clamp(q.x-1.0,0.0,1.0));
            
            color = mix(color,
                        vec3(1.0, 0.592156862745098, 0.4392156862745098),
                        clamp(r.x-0.8,0.0,1.0));
            
            color = mix(color,
                        vec3(1.0, 0.8392156862745098, 0.4392156862745098),
                        clamp(s.x-1.2,0.0,1.0));
            
            gl_FragColor = vec4(color,1.0);
        }
    </script>

    <script id="ascii-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        uniform vec2 uRes;
        uniform sampler2D uRenderTexture;
        uniform sampler2D charSpriteSheet;
        
        void main(){
            //get local position within tile
            vec2 charUv = fract(vTextureCoord * vec2(uRes.x/8.0,uRes.y/8.0));
            
            //get texture sample at bottom left corner of tile
            float dx = 8.0 / uRes.x;
            float dy = 8.0 / uRes.y;
            vec2 gCoord = vec2(dx * floor(vTextureCoord.x / dx),
                               dy * floor(vTextureCoord.y / dy));
            vec4 texSample = texture2D(uRenderTexture,gCoord);
            
            //separate luminance
            float luma = texSample.r*0.2126 + texSample.g*0.7152 +texSample.b*0.0722;
            //select character and by quantized luminance
            charUv.x = (floor(luma * 9.99) + charUv.x) / 10.0;
            vec4 charSample = texture2D(charSpriteSheet,charUv);
            
            //separate chromaticity
            float sum = texSample.r + texSample.g + texSample.b;
            vec3 chroma = vec3(texSample.r/sum, texSample.g/sum, texSample.b/sum);
            //tint character towards chromaticity (bias towards white)
            charSample.rgb = charSample.rgb * (chroma*2.4);

            //set alpha channel from full render
            charSample.a = texture2D(uRenderTexture,vTextureCoord).a;

            //output final color
            gl_FragColor = charSample;
        }
    </script>

    <script id="tile-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        
        uniform vec3 uLight;
        uniform sampler2D uColor;
        uniform sampler2D uNormal;
        uniform sampler2D uRoughness;
        #define AMBIENT 0.4
        void main(){
            vec2  uv = fract(vTextureCoord * 5.0);
            vec3  view  = normalize(vec3(0.0,0.0,1.0)+vVertexPosition);
            vec3  light = normalize(uLight);
            vec3  halfA = normalize(view+light);
            vec3  color = texture2D(uColor, uv).rgb;
            vec3  norm  = normalize((texture2D(uNormal, uv).rgb - 0.5) * 2.0);
            float rough = 1.0 - texture2D(uRoughness, uv).r;

            float diffuse  = max(0.0, dot(uLight, norm));
            float specular = max(0.0, pow(dot(norm, halfA),rough*1024.0));
            vec3  lightColor = vec3(1.0,1.0,1.0) * ((diffuse + specular + AMBIENT)/1.8);
            gl_FragColor = vec4(color*lightColor,1.0);
        }
    </script>

    <script id="water-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        varying vec3 vSurfaceNormal;
        varying float vCaustic;
        uniform vec3 uLight;
        uniform vec2 uRes;
        uniform float uTime;
        uniform sampler2D uTiles;

        #define IOR 1.33
        void main(){
            //getting normalized screenspace position
            vec2 uv = gl_FragCoord.xy / uRes;
            //handling overscan so refractions don't show off texture
            uv += 0.03;
            uv *= 0.96;
            //getting required vectors for lighting
            vec3 norm  = normalize(vSurfaceNormal);
            vec3 view  = normalize(vec3(0.0,0.0,1.0)+vVertexPosition);
            vec3 light = normalize(uLight);
            vec3 halfA = normalize(view+light);
            vec3 refracted = refract(vec3(0.0,0.0,1.0), norm, 1.0/IOR);
            vec3 color = texture2D(uTiles, uv + refracted.xy).rgb;
            //calculating lighting terms
            float caustic = vCaustic * 0.08;
            float diffuse  = max(0.0, dot(uLight, norm));
            float specular = max(0.0, pow(dot(norm, halfA), 2048.0));
            //multiplying lighting terms with light color
            vec3  lightColor = vec3(0.9922,0.9943,0.9975) * (diffuse+specular+caustic);
            //outputting final color
            gl_FragColor = vec4(color * lightColor, 1.0);
        }
    </script>
    <!------------------------------>

    <!-- main script -->
    <script type="module" src="./dist/bundle.js"></script>
    
    <!-- container for the webgl canvas -->
    <div id="canvas"></div>
    
    <!-- actual content starts here -->

    <div class="slide">
        <div class="fractalBg" data-vs-id="simple-vs" data-fs-id="marble-fs"></div>
        <h1 class="title">webgl & curtains.js</h1>
        <p class="intro-text">how melting your gpu can make your website look pretty</p>
    </div>

    <br/>

    <div class="slide">
        <p>what is webgl</p>
    </div>

    <br/>

    <div class="slide">
        <p>3d demo</p>
    </div>

    <br/>

    <div class="slide">
        <div class="fractalBg" data-vs-id="simple-vs" data-fs-id="marble-fs"></div>
        <p>frag shader demo</p>
    </div>

    <br/>

    <div class="slide">
        <p>curtains intro with animated & editable 3d curtain</p>
    </div>

    <br/>

    <div class="slide">
        <div class="asciiBg" data-vs-id="simple-vs" data-fs-id="simple-fs"> 
            <video crossorigin="" src="./video/asciiBg.mp4"></video>
        </div>
        <h1 class="asciiText" id="title1" data-vs-id="text-vs" data-fs-id="rainbowText-fs">
            gwendolyn
        </h1>
        <h1 class="asciiText" id="title2" data-vs-id="text-vs" data-fs-id="rainbowText-fs">
            morgan
        </h1>
        <h1 class="asciiText" id="title3" data-vs-id="text-vs" data-fs-id="rainbowText-fs">
            solberg
        </h1>
        <div class="links">
            <a href="#" class="asciiLinks" data-vs-id="link-vs" data-fs-id="text-fs">
                work
            </a>
            <a href="#" class="asciiLinks" data-vs-id="link-vs" data-fs-id="text-fs">
                about
            </a>
            <a href="#" class="asciiLinks" data-vs-id="link-vs" data-fs-id="text-fs">
                contact
            </a>
        </div>
    </div>

    <br/>
    
    <div class="slide">
        <div class="tileBg" data-vs-id="tile-vs" data-fs-id="tile-fs">
            <img crossorigin="" data-sampler="uColor"     src="./images/tiles-3/Tiles122_4K-JPG_Color.jpg"/>
            <img crossorigin="" data-sampler="uNormal"    src="./images/tiles-3/Tiles122_4K-JPG_NormalGL.jpg">
            <img crossorigin="" data-sampler="uRoughness" src="./images/tiles-3/Tiles122_4K-JPG_Roughness.jpg"/>
        </div>
        <div class="tileContent">
            <div class="tileLogo" data-vs-id="simple-vs" data-fs-id="light-fs">
                <img crossorigin="" src="./images/logo.png"/>
            </div>
            <div class="tileLinks">
                <a href="#" class="tileLink" data-vs-id="text-vs" data-fs-id="tileLink-fs">
                    contact
                </a>
                <a href="#" class="tileLink" data-vs-id="text-vs" data-fs-id="tileLink-fs">
                    about
                </a>
                <a href="#" class="tileLink" data-vs-id="text-vs" data-fs-id="tileLink-fs">
                    shop
                </a>
                <a href="#" class="tileLink" data-vs-id="text-vs" data-fs-id="tileLink-fs">
                    fourth link
                </a>
            </div>
        </div>
        <div class="water" data-vs-id="water-vs" data-fs-id="water-fs"></div>
        <div class="fakeContent">
            <div class="fakeText">
                <p>
                    Lorem ipsum odor amet, consectetuer adipiscing elit. Lectus taciti accumsan orci euismod curabitur. Turpis vestibulum tincidunt inceptos neque est eros porttitor. Sociosqu inceptos quis quis facilisi sociosqu porta aliquam scelerisque. Egestas accumsan arcu dignissim vestibulum fusce. Fermentum lectus ultrices netus montes vestibulum non.
                    <br><br>
                    Quam enim laoreet hendrerit congue eu phasellus maecenas dictum. Egestas rhoncus sociosqu leo netus dui integer. Placerat aptent elit hendrerit arcu nostra, condimentum et nisi. Nunc purus sed nec posuere sem. Porta morbi dapibus accumsan quisque placerat. Facilisi egestas condimentum tortor fames condimentum. Vestibulum sem lacinia aliquam sapien tellus ridiculus aptent.
                    <br><br>
                    Netus enim elit hendrerit ultrices imperdiet parturient. Parturient conubia per placerat a natoque non, penatibus erat. Feugiat massa per mi netus nisl eros placerat semper. Habitasse nulla nullam in posuere; aliquam porta ipsum dolor. Condimentum magnis mollis, est vel risus nulla. Maecenas eleifend facilisis proin venenatis mollis donec. Etiam sit per ullamcorper habitant dictum commodo class? Facilisi libero consectetur litora; pharetra suscipit magnis urna. Lacus euismod volutpat ornare sagittis habitant class scelerisque. Dui blandit semper, nulla faucibus donec tempor.
                    <br><br>
                    Risus dapibus donec metus habitant aliquam. Feugiat etiam primis; quisque hac mauris dui. In convallis conubia ante nullam nibh etiam vestibulum dolor sapien. Aliquet turpis venenatis interdum rutrum dui mi. Lectus tristique egestas nec sodales ante integer maecenas. Augue turpis tristique duis ad gravida. Dui magna platea metus turpis enim magna mus efficitur metus. Scelerisque non blandit mi eget; ullamcorper metus sociosqu suspendisse dis. Donec cras dictum maecenas senectus neque aliquet lacinia. 
                </p>
            </div>
            <div class="fakeImg">
                <img src="./images/testTexture.jpg"/>
            </div>
        </div>
    </div>
</body>
</html>
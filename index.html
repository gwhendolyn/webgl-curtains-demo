<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webgl curtains</title>
    <link rel="stylesheet" href="./stylesheets/global.css"/>
    <link rel="icon" href="./favicon.ico"/>
    <!--google fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
</head>

<body>
    <!--#region vertex shaders ------->
    <script id="simple-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 uTextureMatrix0;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        void main() {
            vec3 vertexPosition = aVertexPosition;
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (uTextureMatrix0 * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="3dDemo-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 uTextureMatrix0;
        uniform float uTime;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        varying float vHeight;

        void main() {
            vec3 vertexPosition = aVertexPosition;
            vertexPosition.z = 0.03 * sin(length(vertexPosition.xy) * 8.0 - uTime * 0.03);
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (uTextureMatrix0 * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
            vHeight = vertexPosition.z;
        }
    </script>

    <script id="text-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 planeTextureMatrix;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        uniform float u_time;
        void main() {
            vec3 vertexPosition = aVertexPosition;
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="curtain-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 planeTextureMatrix;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        uniform float uTime;
        void main() {
            vec3 vertexPosition = aVertexPosition;
            vertexPosition.z = (-vertexPosition.y+1.0) * 0.005 * sin(vertexPosition.x*10.0  + uTime*0.03);
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            
            vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="link-vs" type="x-shader/x-vertex">
        precision mediump float;
        // those are the mandatory attributes that the lib sets
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        //model view and projection matrix
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        //texture matrix that will handle image cover
        uniform mat4 planeTextureMatrix;
        // pass vertex and texture coords to the fragment shader
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        uniform float u_time;
        uniform int u_mouseover;
        void main() {
            vec3 vertexPosition = aVertexPosition;
            
            if (u_mouseover == 1){
                vertexPosition.z = sin(vertexPosition.x + u_time*2.0)*0.05;
            }

            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            // set the varyings
            // here we use our texture matrix to calculate the accurate texture coords
            vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="ascii-vs" type="x-shader/x-vertex">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        uniform mat4 charSpriteSheetMatrix;

        void main(){
            gl_Position = vec4(aVertexPosition, 1.0);

            vTextureCoord = aTextureCoord;
            vVertexPosition = aVertexPosition;
        }
    </script>

    <script id="water-vs" type="x-shader/x-vertex">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uTilesMatrix;
        uniform float uTime;

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        varying vec3 vSurfaceNormal;
        varying float vCaustic;

        float random (in vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        
        #define OCTAVES 12.0
        void main(){
            vec3 vertexPosition = aVertexPosition;
            vec2 samplePos = vertexPosition.xy;
            vec2 directionVector = vec2(0.0);
            float amplitude = 0.008;
            float wavelength = 0.15;
            float speed = 0.03;
            float partialDer = 0.0;
            vec3 binormal = vec3(1.0,0.0,0.0);
            vec3 tangent = vec3(0.0,1.0,0.0);

            for(float i = 1.0; i < OCTAVES+1.0; i++){
                //generate random direction vector
                directionVector.x = (random(vec2(i*1.3,i+1.2))-0.5)*2.0;
                directionVector.y = (random(vec2(i+1.11,i*1.5))-0.5)*2.0;
                directionVector = normalize(directionVector);
                
                //calculate wave height contribution and add to vertex z coord
                float val = amplitude * sin(dot(directionVector, samplePos) * (2.0/wavelength) + uTime * speed);
                vertexPosition.z += val;
                
                //calculate partial derivative and add to total derivative/ binormal and tangent z components
                partialDer = -amplitude * cos(dot(directionVector, samplePos) * (2.0/wavelength) + uTime * speed);
                binormal.z += directionVector.x * partialDer;
                tangent.z += directionVector.y * partialDer;
                
                
                //adjust params
                amplitude *= 0.85;
                wavelength *= 0.85;
                samplePos.x += partialDer * directionVector.x;
                samplePos.y += partialDer * directionVector.y;
                speed *= 1.02;
            }

            vSurfaceNormal = cross(binormal, tangent);
            
            
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); 
            vTextureCoord = (uTilesMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>

    <script id="wiggle-vs" type="x-shader/x-vertex">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif
        
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uTextureMatrix0;
        uniform float uTime;
        uniform vec2 uDrag;
        
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        void main() {
            vec3 vertexPosition = aVertexPosition;
            vec2 dragDirection = normalize(uDrag);
            vertexPosition.z = 0.07 * sin(clamp((vertexPosition.x-1.0)+uTime/10.0,0.0,2.0));
            if(length(uDrag) != 0.0){
                vertexPosition.x += dragDirection.x * length(vertexPosition.xy+dragDirection)*(abs(uDrag.x)/400.0);
                vertexPosition.y += -(dragDirection.y * length(vertexPosition.xy-dragDirection))*(abs(uDrag.y)/400.0);
            }
            gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0);
            vTextureCoord = (uTextureMatrix0 * vec4(aTextureCoord, 0.0, 1.0)).xy;
            vVertexPosition = vertexPosition;
        }
    </script>
    <!--#endregion--------------------------->

    <!--#region fragment shaders ----->
    <script id="simple-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D uSampler0;
        void main() {
            gl_FragColor = texture2D(uSampler0, vTextureCoord);
        }
    </script>

    <script id="3dDemo-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        varying float vHeight;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D uSampler0;
        void main() {
            vec4 sample = texture2D(uSampler0, vTextureCoord);
            sample.rgb *= vHeight*20.0+1.0;
            gl_FragColor = sample;
        }
    </script>

    <script id="text-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D planeTexture;
        void main() {
            gl_FragColor = texture2D(planeTexture, vTextureCoord);
        }
    </script>

    <script id="curtain-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D planeTexture;
        uniform float uTime;
        void main() {
            vec4 sample = texture2D(planeTexture, vTextureCoord);
            float highLight = (1.0 - vTextureCoord.y) * 0.005 * sin((vTextureCoord.x-0.5)*20.0  + uTime*0.03);
            vec3 bgColor = vec3(0.7568627450980,
                                0.0705882352941,
                                0.1215686274509);
            sample.rgb = mix(sample.rgb, bgColor, 1.0 - sample.a);
            sample.rgb += highLight * 40.0;
            gl_FragColor = vec4(sample.rgb, 1.0);
        }
    </script>

    <script id="rainbowText-fs" type="x-shader/x-fragment">
        precision mediump float;
        // get our varyings
        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        // our texture sampler (default name, to use a different name please refer to the documentation)
        uniform sampler2D planeTexture;
        uniform float u_time;
        void main() {
            vec4 sample = texture2D(planeTexture, vTextureCoord);
            float phase = (u_time/4.0)+vTextureCoord.x*3.0;
            sample.rgb = sample.rgb * ((sin(phase)*0.5)+0.7) * vec3(0.7,1.0,1.0);
            gl_FragColor = sample;
        }
    </script>

    <script id="marble-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_time;
        uniform sampler2D uSampler0;

        varying vec2 vTextureCoord;
        float random (in vec2 _st) {
            return fract(sin(dot(_st.xy,
                                vec2(12.9898,78.233)))*
                43758.5453123);
        }

        // Based on Morgan McGuire @morgan3d
        // https://www.shadertoy.com/view/4dS3Wd
        float noise (in vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            // Four corners in 2D of a tile
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);

            return mix(a, b, u.x) +
                    (c - a)* u.y * (1.0 - u.x) +
                    (d - b) * u.x * u.y;
        }

        #define NUM_OCTAVES 6

        float fbm ( in vec2 _st) {
            float v = 0.0;
            float a = 1.5;
            vec2 shift = vec2(100.0);
            mat2 rot = mat2(cos(0.5), sin(0.5),
                            -sin(0.5), cos(0.50));
            for (int i = 0; i < NUM_OCTAVES; ++i) {
                v += a * noise(_st);
                _st = rot * _st * 2.0 + shift;
                a *= 0.5;
            }
            return v;
        }

        #define TIME_SCALE 0.065
        void main() {
            vec2 st = gl_FragCoord.xy/u_resolution.xy;
            st.x *= u_resolution.x/u_resolution.y;
            
            vec2 ms = u_mouse.xy/u_resolution.xy;
            ms.x *= u_resolution.x/u_resolution.y;
            float mouseProx = sqrt(pow(st.x-ms.x,2.0)+pow(st.y-ms.y,2.0));

            vec2 q = vec2(0.0);
            q.x = fbm(6.*st+u_time*(TIME_SCALE+0.015));
            q.y = fbm(6.*st+u_time*(TIME_SCALE+0.015));

            vec2 r = vec2(0.0);
            r.x = fbm((abs(mouseProx)*1.)*st + q+u_time*(TIME_SCALE+0.01));
            r.y = fbm((abs(mouseProx)*1.)*st + q+u_time*(TIME_SCALE+0.01));

            vec2 s = vec2(0.0);
            s.x = fbm(5.0*st + r+u_time*(TIME_SCALE+0.005));
            s.y = fbm(5.0*st + r+u_time*(TIME_SCALE+0.005));

            float t = fbm(st+s);

            vec3 color = vec3(t);
            
            color = mix(vec3(1.0, 1.0, 1.0),
                        vec3(0.4392156862745098, 0.8392156862745098, 1.0),
                        clamp(t-0.5,0.0,1.0));
            
            color = mix(color,
                        vec3(1.0, 0.4392156862745098, 0.6509803921568627),
                        clamp(q.x-1.0,0.0,1.0));
            
            color = mix(color,
                        vec3(1.0, 0.592156862745098, 0.4392156862745098),
                        clamp(r.x-0.8,0.0,1.0));
            
            color = mix(color,
                        vec3(1.0, 0.8392156862745098, 0.4392156862745098),
                        clamp(s.x-1.2,0.0,1.0));
            
            gl_FragColor = vec4(color,1.0);
        }
    </script>

    <script id="ascii-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;

        uniform vec2 uRes;
        uniform sampler2D uRenderTexture;
        uniform sampler2D charSpriteSheet;
        
        void main(){
            //get local position within tile
            vec2 charUv = fract(vTextureCoord * vec2(uRes.x/8.0,uRes.y/8.0));
            
            //get texture sample at bottom left corner of tile
            float dx = 8.0 / uRes.x;
            float dy = 8.0 / uRes.y;
            vec2 gCoord = vec2(dx * floor(vTextureCoord.x / dx),
                               dy * floor(vTextureCoord.y / dy));
            vec4 texSample = texture2D(uRenderTexture,gCoord);
            
            //separate luminance
            float luma = texSample.r*0.2126 + texSample.g*0.7152 +texSample.b*0.0722;
            //select character and by quantized luminance
            charUv.x = (floor(luma * 9.99) + charUv.x) / 10.0;
            vec4 charSample = texture2D(charSpriteSheet,charUv);
            
            //separate chromaticity
            float sum = texSample.r + texSample.g + texSample.b;
            vec3 chroma = vec3(texSample.r/sum, texSample.g/sum, texSample.b/sum);
            //tint character towards chromaticity (bias towards white)
            charSample.rgb = charSample.rgb * (chroma*2.4);

            //set alpha channel from full render
            charSample.a = texture2D(uRenderTexture,vTextureCoord).a;

            //output final color
            gl_FragColor = charSample;
        }
    </script>

    <script id="water-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        varying vec3 vSurfaceNormal;
        varying float vCaustic;
        uniform vec3 uLight;
        uniform float uTime;


        #define IOR 1.33
        void main(){
            //getting required vectors for lighting
            mat3 rotate = mat3(1.0, 0.0       , 0.0,
                               0.0, cos(1.308996939), -sin(1.308996939),
                               0.0, sin(1.308996939), cos(1.308996939));
            
            vec3 view  = normalize(vec3(0.0,1.0,0.26795)+vVertexPosition) * rotate;
            vec3 norm  = normalize(vSurfaceNormal * rotate);
            vec3 light = normalize(uLight) * rotate;
            vec3 halfA = normalize(view+light);
            //calculating lighting terms
            vec3 ambient = 0.01 * vec3(3.0/255.0, 4.0/255.0, 94.0/255.0);
            vec3 diffuse  = max(0.0, dot(light, norm)) * vec3(173.0/255.0, 232.0/255.0, 244.0/255.0);
            vec3 specular = pow((1.0-dot(view,norm)),5.0) * max(0.0, pow(dot(norm, halfA), 32.0)) * vec3(253.0/255.0,252.0/255.0,220.0/255.0);
            //outputting final color
            gl_FragColor = vec4(ambient + diffuse + specular, 1.0);
        }
    </script>

    <script id="caustic-fs" type="x-shader/x-fragment">
        #version 100
        #ifdef GL_ES
        precision mediump float;
        #endif

        varying vec3 vVertexPosition;
        varying vec2 vTextureCoord;
        
        uniform float uTime;
        uniform sampler2D uSampler0;
        #define CAUSTIC_SCALE 1.4
        #define CAUSTIC_SPEED 0.2
        void main(){
            vec2 uv1 = vec2(fract(vTextureCoord*CAUSTIC_SCALE + CAUSTIC_SPEED * 0.75 * uTime * 0.005));
            vec3 sample1 = texture2D(uSampler0, uv1).rgb;
            float luma1 = sample1.r*0.2126 + sample1.g*0.7152 + sample1.b*0.0722;
            
            vec2 uv2 = vec2(fract(vTextureCoord*-CAUSTIC_SCALE + CAUSTIC_SPEED * uTime * 0.005));
            vec3 sample2 = texture2D(uSampler0, uv2).rgb;
            float luma2 = sample2.r*0.2126 + sample2.g*0.7152 + sample2.b*0.0722;
            
            vec3 color = min(sample1, sample2);
            float fadeout = 1.0 - smoothstep(0.92, 1.0, vTextureCoord.y);
            gl_FragColor=vec4(color*3.0, 0.20 * fadeout);
        }
    </script>
    <!--#endregion---------------------------->

    <!-- main script -->
    <script type="module" src="./dist/bundle.js"></script>
    
    <!-- container for the webgl canvas -->
    <div id="canvas"></div>
    
    <!-- actual content starts here -->

    <div class="slide">
        <div class="fractalBg" data-vs-id="simple-vs" data-fs-id="marble-fs"></div>
        <h1 class="title">webgl & curtains.js</h1>
        <p class="intro-text">how melting your gpu can make your website look pretty</p>
    </div>

    <br/>

    <div class="slide">
        <div class="introImgContainer">
            <img class="introImg" id="small" src="./images/WebGL_Logo.png"/>
            <img class="introImg" src="./images/OpenGL_pipeline.png"/>
        </div>
    </div>

    <br/>

    <div class="slide">
        <div class="a3dDemo" data-vs-id="3dDemo-vs" data-fs-id="3dDemo-fs">
            <img crossorigin="" src="./images/wall.webp"/>
        </div>
    </div>

    <br/>

    <div class="slide">
        <div class="fractalBg" data-vs-id="simple-vs" data-fs-id="marble-fs"></div>
    </div>

    <br/>

    <div class="slide">
        <h1 class="curtain" data-vs-id="curtain-vs" data-fs-id="curtain-fs">
            curtains.js
        </h1>
    </div>

    <br/>

    <div class="slide">
        <div class="asciiBg" data-vs-id="simple-vs" data-fs-id="simple-fs"> 
            <video crossorigin="" src="./video/asciiBg.mp4"></video>
        </div>
        <h1 class="asciiText" id="title1" data-vs-id="text-vs" data-fs-id="rainbowText-fs">
            gwendolyn
        </h1>
        <h1 class="asciiText" id="title2" data-vs-id="text-vs" data-fs-id="rainbowText-fs">
            morgan
        </h1>
        <h1 class="asciiText" id="title3" data-vs-id="text-vs" data-fs-id="rainbowText-fs">
            solberg
        </h1>
        <div class="links">
            <a href="#" class="asciiLinks" data-vs-id="link-vs" data-fs-id="text-fs">
                work
            </a>
            <a href="#" class="asciiLinks" data-vs-id="link-vs" data-fs-id="text-fs">
                about
            </a>
            <a href="#" class="asciiLinks" data-vs-id="link-vs" data-fs-id="text-fs">
                contact
            </a>
        </div>
    </div>

    <br/>
    
    <div class="slide" id="big">
        <div class="water" data-vs-id="water-vs" data-fs-id="water-fs"></div>
        <div class="caustics" data-vs-id="simple-vs" data-fs-id="caustic-fs">
            <img crossorigin="" src="./images/caustics.jpg"/>
        </div>
        <div class="logo">
            <img src="./images/logo.png"/>
        </div>
        <div class="row" id="nav">
            <a class="navLink">About</a>

            <div class="navSep"></div>

            <a class="navLink">Contact</a>

            <div class="navSep"></div>

            <a class="navLink">News</a>

            <div class="navSep"></div>

            <a class="navLink">Fourth Link</a>
        </div>
        <div class="row">
            <div class="col" id="half">
                <p>
                This is some text, I'm not sure what this company even is, 
                do they do oceanographic research? do they sell boats? it 
                doesn't really matter because they don't actually exist I suppose. 
                I do find the idea of an oceanographic research group having a 
                website blasted with 3d graphics kinda funny so I guess it's that 
                now that I think about it. anyway, this is just some text to fill 
                out the space and make this look like a real website. The content
                isn't really what this demo is about, it's more about demoing webgl
                and curtains so what is written here is immaterial to that.
                <br><br>
                Physically based rendering (PBR) is a computer graphics approach 
                that seeks to render images in a way that models the lights and 
                surfaces with optics in the real world. It is often referred to as 
                "Physically Based Lighting" or "Physically Based Shading". Many PBR 
                pipelines aim to achieve photorealism. Feasible and quick 
                approximations of the bidirectional reflectance distribution function 
                and rendering equation are of mathematical importance in this field. 
                Photogrammetry may be used to help discover and encode accurate 
                optical properties of materials. PBR principles may be implemented 
                in real-time applications using Shaders or offline applications using 
                ray tracing or path tracing.
                <br><br>
                PBR is, as Joe Wilson puts it, "more of a concept than a strict set 
                of rules" but the concept contains several distinctive points of 
                note. One of these is that unlike many previous models that sought 
                to differentiate surfaces between non-reflective and reflective PBR 
                recognizes that, in the real world, as John Hable puts it, 
                "everything is shiny". Even "flat" or "matte" surfaces in the real 
                world such as concrete will reflect a small degree of light, and 
                many metals and liquids will reflect a great deal of it. Another 
                thing that PBR models attempt to do is to integrate photogrammetry 
                measurements from photographs of real-world materials to study and 
                replicate real physical ranges of values to accurately simulate 
                albedo, gloss, reflectivity, and other physical properties. 
                Finally, PBR puts a great deal of emphasis on microfacets, and will 
                often contain additional textures and mathematical models intended 
                to model small-scale specular highlights and cavities resulting 
                from smoothness or roughness in addition to traditional specular or 
                reflectivity maps. 
                <br><br>
                <em>[from Wikipedia (the free encyclopedia)]</em>
                </p>
            </div>
            <div class="col" id="half">
                <div class="row">
                    <div class="col" id="half">
                        <a draggable="false" href="https://en.wikipedia.org/wiki/Physically_based_rendering">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/491px-Physically_Based_Rendering_Sample_2.png"/>
                        </div>
                        </a>
                        <p><em>render of diamond plate</em></p>
                    </div>
                    <div class="col" id="half">
                        <a draggable="false" href="https://en.wikipedia.org/wiki/Physically_based_rendering">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/Physically_Based_Rendering_Sample_1.png"/>
                        </div>
                        </a>
                        <p><em>render of bricks</em></p>
                    </div>
                </div>
                <div class="row">
                    <div class="col" id="half">
                        <a draggable="false" href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/Recursive_raytrace_of_a_sphere.png"/>
                        </div>
                        </a>
                        <p><em>raytraced render of a sphere</em></p>
                    </div>
                    <div class="col" id="half">
                        <a draggable="false" href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/Ray-traced_steel_balls.jpg"/>
                        </div>
                        </a>
                        <p><em>raytraced render of steel balls</em></p>
                    </div>
                </div>
            </div>
        </div>
        <div class="row" id="title">
            <p>Unused tile textures from an earlier revision of this scene</p>
        </div>
        <div class="row"> 
            <div class="col" id="oneQuarter">
                <img crossorigin="" src="./images/tiles-3/Tiles122_4K-JPG_Color.jpg"/>
                <p><em>albedo</em></p>
            </div>
            <div class="col" id="oneQuarter">
                <img crossorigin="" src="./images/tiles-3/Tiles122_4K-JPG_NormalGL.jpg"/>
                <p><em>normal vectors</em></p>
            </div>
            <div class="col" id="oneQuarter">
                <img crossorigin="" src="./images/tiles-3/Tiles122_4K-JPG_Roughness.jpg"/>
                <p><em>roughness</em></p>
            </div>
            <div class="col" id="oneQuarter">
                <img crossorigin="" src="./images/tiles-3/Tiles122_4K-JPG_AmbientOcclusion.jpg"/>
                <p><em>ambient occlusion</em></p>
            </div>
        </div>
        <div class="row">
            <div class="col" id="half">
                <div class="row">
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig01-01.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 1-1</em></p>
                    </div>
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig01-02.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 1-2</em></p>
                    </div>
                </div>
                <div class="row">
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig01-03.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 1-3</em></p>
                    </div>
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig01-04.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 1-4</em></p>
                    </div>
                </div>
            </div>
            <div class="col" id="half">
                <h1>Chapter 1. Effective Water Simulation from Physical Models</h1>
                <p>
                This chapter describes a system for simulating and rendering large 
                bodies of water on the GPU. The system combines geometric undulations 
                of a base mesh with generation of a dynamic normal map. The system has 
                proven suitable for real-time game scenarios, having been used 
                extensively in Cyan Worlds' Uru: Ages Beyond Myst, as shown in 
                Figure 1-1.
                </p>
                <h2>1.1 Goals and Scope</h2>
                <p>
                Real-time rendering techniques have been migrating from the 
                offline-rendering world over the last few years. Fast Fourier 
                Transform (FFT) techniques, as outlined in Tessendorf 2001, produce 
                incredible realism for sufficiently large sampling grids, and 
                moderate-size grids may be processed in real time on consumer-level 
                PCs. Voxel-based solutions to simplified forms of the Navier-Stokes 
                equations are also viable (Yann 2003). Although we have not yet 
                reached the point of cutting-edge, offline fluid simulations, as in 
                Enright et al. 2002, the gap is closing. By the time this chapter is 
                published, FFT libraries will likely be available for vertex and 
                pixel shaders, but as of this writing, even real-time versions of 
                these techniques are limited to implementation on the CPU.
                <br><br>
                At the same time, water simulation models simple enough to run on 
                the GPU have been evolving upward as well. Isidoro et al. 2002 
                describes summing four sine waves in a vertex shader to compute 
                surface height and orientation. Laeuchli 2002 presents a shader 
                calculating surface height using three Gerstner waves. We start 
                with summing simple sine functions, then progress to slightly more 
                complicated functions, as appropriate. We also extend the technique 
                into the realm of pixel shaders, using a sum of periodic wave 
                functions to create a dynamic tiling bump map to capture the finer 
                details of the water surface.
                <br><br>
                This chapter focuses on explaining the physical significance of the 
                system parameters, showing that approximating a water surface with 
                a sum of sine waves is not as ad hoc as often presented. We pay 
                special attention to the math that takes us from the underlying 
                model to the actual implementation; the math is key to extending the 
                implementation. This system is designed for bodies of water ranging 
                from a small pond to the ocean as viewed from a cove or island. 
                Although not a rigorous physical simulation, it does deliver 
                convincing, flexible, and dynamic renderings of water. Because the 
                simulation runs entirely on the GPU, it entails no struggle over 
                CPU usage with either artificial intelligence (AI) or physics 
                processes. Because the system parameters do have a physical basis, 
                they are easier to script than if they were found by trial and 
                error. Making the system as a whole dynamic—in addition to its 
                component waves—adds an extra level of life.
                </p>
            </div>
        </div>
        <div class="row">
            <div class="col" id="half">
                <h1>Chapter 2. Rendering Water Caustics</h1>
                <h2>2.1 Introduction</h2>
                <p>
                There is something hypnotic about the way water interacts with 
                light: the subtle reflections and refractions, the way light bends 
                to form dancing caustics on the bottom of the sea, and the infinitely 
                varied look of the ocean surface. See Figure 2-1. These phenomena and 
                their complexity have attracted many researchers from the fields of 
                physics and, in recent years, computer graphics. Simulating and rendering 
                realistic water is, like simulating fire, a fascinating task. It is not 
                easy to achieve good results at interactive frame rates, and thus creative 
                approaches must often be taken.
                <br><br>
                Caustics result from light rays reflecting or refracting from a curved surface 
                and hence focusing only in certain areas of the receiving surface. This chapter 
                explains an aesthetics-driven method for rendering underwater caustics in real time. 
                Our purely aesthetics-driven approach simply leaves realism out of consideration. 
                The result is a scene that looks good, but may not correctly simulate the physics
                of the setting. As we show in this chapter, the results of our approach look
                remarkably realistic, and the method can be implemented easily on most graphics 
                hardware. This simplified approach has proven very successful in many fractal-related 
                disciplines, such as mountain and cloud rendering or tree modeling. The purpose 
                of this chapter is to expose a new technique for rendering real-time 
                caustics, describing the method from its physical foundations to its 
                implementation details. Because the technique is procedural, it yields 
                elegantly to an implementation using a high-level shading language.
                <br><br>
                <em>this and previous section taken from the first edition of GPU Gems</em>
                </p>
            </div>
            <div class="col" id="half">
                <div class="row">
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-2-rendering-water-caustics">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig02-01a.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 2-1</em></p>
                    </div>
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-2-rendering-water-caustics">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig02-02.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 2-2</em></p>
                    </div>
                </div>
                <div class="row">
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-2-rendering-water-caustics">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig02-03.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 2-3</em></p>
                    </div>
                    <div class="col" id="half">
                        <a draggable="false" href="https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-2-rendering-water-caustics">
                        <div class="mouseoverWiggle" data-vs-id="wiggle-vs" data-fs-id="simple-fs">
                            <img crossorigin="" src="./images/fig02-06a.jpg"/>
                        </div>
                        </a>
                        <p><em>figure 2-6</em></p>
                    </div>
                </div>
            </div>
        </div>
        <hr>
        <div class="row" id="foot">
            <p>created by <em>gwendolyn morgan solberg</em></p>
        </div>
    </div>
</body>
</html>